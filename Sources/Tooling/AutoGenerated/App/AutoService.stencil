{% for type in types.implementing.AutoService %}
{% macro repositoryType type %}{% for inheritedTypeName in type.inheritedTypes %}{% for inheritedType in types.protocols where inheritedType.name == inheritedTypeName %}{% if inheritedType.implements.EntityRepository %}{{inheritedType.name}}{% endif %}{% endfor %}{% endfor %}{% endmacro %}
// sourcery:file:AutoService/{{type.name}}+AutoService.generated.swift
import Domain

import Vapor

// MARK: {{type.name}}

/// Adapter for the domain layers `{{type.name}}` to be used with Vapor.
///
/// This adds the functionality needed that this repository can be injected by Vaporâ€˜s dependency
/// injection framework.
extension {{type.name}}: ServiceType {

    // MARK: Service

{% if type.implements.Actor %}
    public static let serviceSupports: [Any.Type] = [{{type.name|replace:"Domain",""}}.self]

    public static func makeService(for container: Container) throws -> Self {
        {% for initializer in type.initializers %}
            {% if initializer.isRequired %}
        return try .init(
        {% for parameter in initializer.parameters %}
            {{parameter.name}}: container.make(){% if not forloop.last %},{% endif %}
        {% endfor %}
        )
            {% endif %}
        {% endfor %}
    }
{% endif %}
{% if type.implements.EntityRepository %}
    public static let serviceSupports: [Any.Type] = [{% call repositoryType type %}.self]

    public static func makeService(for worker: Container) throws -> Self {
        {% if type.implements.MySQLModelRepository %}
        return .init(try worker.connectionPool(to: .mysql))
        {% else %}
        fatalError("Code generation for AutoRepositoryService failed on '{{type.name}}'")
        {% endif %}
    }
{% endif %}

}
// sourcery:end
{% endfor %}
